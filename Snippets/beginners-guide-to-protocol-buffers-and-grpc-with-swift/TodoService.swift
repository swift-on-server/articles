import GRPCNIOTransportHTTP2
import GRPCProtobuf

// snippet.hide
import GRPCCore
import SwiftProtobuf
// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: todo_messages.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

/// todo_messages.proto

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// 2.
struct Todos_Empty: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 3.
struct Todos_TodoID: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var todoID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 4.
struct Todos_Todo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var todoID: String {
    get {return _todoID ?? String()}
    set {_todoID = newValue}
  }
  /// Returns true if `todoID` has been explicitly set.
  var hasTodoID: Bool {return self._todoID != nil}
  /// Clears the value of `todoID`. Subsequent reads from it will return its default value.
  mutating func clearTodoID() {self._todoID = nil}

  var title: String = String()

  var completed: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _todoID: String? = nil
}

/// 5.
struct Todos_TodoList: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var todos: [Todos_Todo] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "todos"

extension Todos_Empty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Empty"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Todos_Empty, rhs: Todos_Empty) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Todos_TodoID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TodoID"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "todoID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.todoID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.todoID.isEmpty {
      try visitor.visitSingularStringField(value: self.todoID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Todos_TodoID, rhs: Todos_TodoID) -> Bool {
    if lhs.todoID != rhs.todoID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Todos_Todo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Todo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "todoID"),
    2: .same(proto: "title"),
    3: .same(proto: "completed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._todoID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.completed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._todoID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if self.completed != false {
      try visitor.visitSingularBoolField(value: self.completed, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Todos_Todo, rhs: Todos_Todo) -> Bool {
    if lhs._todoID != rhs._todoID {return false}
    if lhs.title != rhs.title {return false}
    if lhs.completed != rhs.completed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Todos_TodoList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TodoList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "todos"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.todos) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.todos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.todos, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Todos_TodoList, rhs: Todos_TodoList) -> Bool {
    if lhs.todos != rhs.todos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
/// todo.proto

// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the gRPC Swift generator plugin for the protocol buffer compiler.
// Source: todo_service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/grpc/grpc-swift

import GRPCCore
import GRPCProtobuf

internal enum Todos_TodoService {
    internal static let descriptor = GRPCCore.ServiceDescriptor.todos_TodoService
    internal enum Method {
        internal enum FetchTodos {
            internal typealias Input = Todos_Empty
            internal typealias Output = Todos_TodoList
            internal static let descriptor = GRPCCore.MethodDescriptor(
                service: Todos_TodoService.descriptor.fullyQualifiedService,
                method: "FetchTodos"
            )
        }
        internal enum CreateTodo {
            internal typealias Input = Todos_Todo
            internal typealias Output = Todos_Todo
            internal static let descriptor = GRPCCore.MethodDescriptor(
                service: Todos_TodoService.descriptor.fullyQualifiedService,
                method: "CreateTodo"
            )
        }
        internal enum DeleteTodo {
            internal typealias Input = Todos_TodoID
            internal typealias Output = Todos_Empty
            internal static let descriptor = GRPCCore.MethodDescriptor(
                service: Todos_TodoService.descriptor.fullyQualifiedService,
                method: "DeleteTodo"
            )
        }
        internal enum CompleteTodo {
            internal typealias Input = Todos_TodoID
            internal typealias Output = Todos_Todo
            internal static let descriptor = GRPCCore.MethodDescriptor(
                service: Todos_TodoService.descriptor.fullyQualifiedService,
                method: "CompleteTodo"
            )
        }
        internal static let descriptors: [GRPCCore.MethodDescriptor] = [
            FetchTodos.descriptor,
            CreateTodo.descriptor,
            DeleteTodo.descriptor,
            CompleteTodo.descriptor
        ]
    }
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    internal typealias StreamingServiceProtocol = Todos_TodoService_StreamingServiceProtocol
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    internal typealias ServiceProtocol = Todos_TodoService_ServiceProtocol
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    internal typealias ClientProtocol = Todos_TodoService_ClientProtocol
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    internal typealias Client = Todos_TodoService_Client
}

extension GRPCCore.ServiceDescriptor {
    internal static let todos_TodoService = Self(
        package: "todos",
        service: "TodoService"
    )
}

/// 2. 
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
internal protocol Todos_TodoService_StreamingServiceProtocol: GRPCCore.RegistrableRPCService {
    /// 3. 
    func fetchTodos(
        request: GRPCCore.StreamingServerRequest<Todos_Empty>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.StreamingServerResponse<Todos_TodoList>
    
    /// 4. 
    func createTodo(
        request: GRPCCore.StreamingServerRequest<Todos_Todo>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.StreamingServerResponse<Todos_Todo>
    
    /// 5. 
    func deleteTodo(
        request: GRPCCore.StreamingServerRequest<Todos_TodoID>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.StreamingServerResponse<Todos_Empty>
    
    /// 6. 
    func completeTodo(
        request: GRPCCore.StreamingServerRequest<Todos_TodoID>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.StreamingServerResponse<Todos_Todo>
}

/// Conformance to `GRPCCore.RegistrableRPCService`.
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Todos_TodoService.StreamingServiceProtocol {
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    internal func registerMethods(with router: inout GRPCCore.RPCRouter) {
        router.registerHandler(
            forMethod: Todos_TodoService.Method.FetchTodos.descriptor,
            deserializer: GRPCProtobuf.ProtobufDeserializer<Todos_Empty>(),
            serializer: GRPCProtobuf.ProtobufSerializer<Todos_TodoList>(),
            handler: { request, context in
                try await self.fetchTodos(
                    request: request,
                    context: context
                )
            }
        )
        router.registerHandler(
            forMethod: Todos_TodoService.Method.CreateTodo.descriptor,
            deserializer: GRPCProtobuf.ProtobufDeserializer<Todos_Todo>(),
            serializer: GRPCProtobuf.ProtobufSerializer<Todos_Todo>(),
            handler: { request, context in
                try await self.createTodo(
                    request: request,
                    context: context
                )
            }
        )
        router.registerHandler(
            forMethod: Todos_TodoService.Method.DeleteTodo.descriptor,
            deserializer: GRPCProtobuf.ProtobufDeserializer<Todos_TodoID>(),
            serializer: GRPCProtobuf.ProtobufSerializer<Todos_Empty>(),
            handler: { request, context in
                try await self.deleteTodo(
                    request: request,
                    context: context
                )
            }
        )
        router.registerHandler(
            forMethod: Todos_TodoService.Method.CompleteTodo.descriptor,
            deserializer: GRPCProtobuf.ProtobufDeserializer<Todos_TodoID>(),
            serializer: GRPCProtobuf.ProtobufSerializer<Todos_Todo>(),
            handler: { request, context in
                try await self.completeTodo(
                    request: request,
                    context: context
                )
            }
        )
    }
}

/// 2. 
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
internal protocol Todos_TodoService_ServiceProtocol: Todos_TodoService.StreamingServiceProtocol {
    /// 3. 
    func fetchTodos(
        request: GRPCCore.ServerRequest<Todos_Empty>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.ServerResponse<Todos_TodoList>
    
    /// 4. 
    func createTodo(
        request: GRPCCore.ServerRequest<Todos_Todo>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.ServerResponse<Todos_Todo>
    
    /// 5. 
    func deleteTodo(
        request: GRPCCore.ServerRequest<Todos_TodoID>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.ServerResponse<Todos_Empty>
    
    /// 6. 
    func completeTodo(
        request: GRPCCore.ServerRequest<Todos_TodoID>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.ServerResponse<Todos_Todo>
}

/// Partial conformance to `Todos_TodoService_StreamingServiceProtocol`.
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Todos_TodoService.ServiceProtocol {
    internal func fetchTodos(
        request: GRPCCore.StreamingServerRequest<Todos_Empty>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.StreamingServerResponse<Todos_TodoList> {
        let response = try await self.fetchTodos(
            request: GRPCCore.ServerRequest(stream: request),
            context: context
        )
        return GRPCCore.StreamingServerResponse(single: response)
    }
    
    internal func createTodo(
        request: GRPCCore.StreamingServerRequest<Todos_Todo>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.StreamingServerResponse<Todos_Todo> {
        let response = try await self.createTodo(
            request: GRPCCore.ServerRequest(stream: request),
            context: context
        )
        return GRPCCore.StreamingServerResponse(single: response)
    }
    
    internal func deleteTodo(
        request: GRPCCore.StreamingServerRequest<Todos_TodoID>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.StreamingServerResponse<Todos_Empty> {
        let response = try await self.deleteTodo(
            request: GRPCCore.ServerRequest(stream: request),
            context: context
        )
        return GRPCCore.StreamingServerResponse(single: response)
    }
    
    internal func completeTodo(
        request: GRPCCore.StreamingServerRequest<Todos_TodoID>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.StreamingServerResponse<Todos_Todo> {
        let response = try await self.completeTodo(
            request: GRPCCore.ServerRequest(stream: request),
            context: context
        )
        return GRPCCore.StreamingServerResponse(single: response)
    }
}

/// 2. 
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
internal protocol Todos_TodoService_ClientProtocol: Sendable {
    /// 3. 
    func fetchTodos<R>(
        request: GRPCCore.ClientRequest<Todos_Empty>,
        serializer: some GRPCCore.MessageSerializer<Todos_Empty>,
        deserializer: some GRPCCore.MessageDeserializer<Todos_TodoList>,
        options: GRPCCore.CallOptions,
        _ body: @Sendable @escaping (GRPCCore.ClientResponse<Todos_TodoList>) async throws -> R
    ) async throws -> R where R: Sendable
    
    /// 4. 
    func createTodo<R>(
        request: GRPCCore.ClientRequest<Todos_Todo>,
        serializer: some GRPCCore.MessageSerializer<Todos_Todo>,
        deserializer: some GRPCCore.MessageDeserializer<Todos_Todo>,
        options: GRPCCore.CallOptions,
        _ body: @Sendable @escaping (GRPCCore.ClientResponse<Todos_Todo>) async throws -> R
    ) async throws -> R where R: Sendable
    
    /// 5. 
    func deleteTodo<R>(
        request: GRPCCore.ClientRequest<Todos_TodoID>,
        serializer: some GRPCCore.MessageSerializer<Todos_TodoID>,
        deserializer: some GRPCCore.MessageDeserializer<Todos_Empty>,
        options: GRPCCore.CallOptions,
        _ body: @Sendable @escaping (GRPCCore.ClientResponse<Todos_Empty>) async throws -> R
    ) async throws -> R where R: Sendable
    
    /// 6. 
    func completeTodo<R>(
        request: GRPCCore.ClientRequest<Todos_TodoID>,
        serializer: some GRPCCore.MessageSerializer<Todos_TodoID>,
        deserializer: some GRPCCore.MessageDeserializer<Todos_Todo>,
        options: GRPCCore.CallOptions,
        _ body: @Sendable @escaping (GRPCCore.ClientResponse<Todos_Todo>) async throws -> R
    ) async throws -> R where R: Sendable
}

@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Todos_TodoService.ClientProtocol {
    internal func fetchTodos<R>(
        request: GRPCCore.ClientRequest<Todos_Empty>,
        options: GRPCCore.CallOptions = .defaults,
        _ body: @Sendable @escaping (GRPCCore.ClientResponse<Todos_TodoList>) async throws -> R = {
            try $0.message
        }
    ) async throws -> R where R: Sendable {
        try await self.fetchTodos(
            request: request,
            serializer: GRPCProtobuf.ProtobufSerializer<Todos_Empty>(),
            deserializer: GRPCProtobuf.ProtobufDeserializer<Todos_TodoList>(),
            options: options,
            body
        )
    }
    
    internal func createTodo<R>(
        request: GRPCCore.ClientRequest<Todos_Todo>,
        options: GRPCCore.CallOptions = .defaults,
        _ body: @Sendable @escaping (GRPCCore.ClientResponse<Todos_Todo>) async throws -> R = {
            try $0.message
        }
    ) async throws -> R where R: Sendable {
        try await self.createTodo(
            request: request,
            serializer: GRPCProtobuf.ProtobufSerializer<Todos_Todo>(),
            deserializer: GRPCProtobuf.ProtobufDeserializer<Todos_Todo>(),
            options: options,
            body
        )
    }
    
    internal func deleteTodo<R>(
        request: GRPCCore.ClientRequest<Todos_TodoID>,
        options: GRPCCore.CallOptions = .defaults,
        _ body: @Sendable @escaping (GRPCCore.ClientResponse<Todos_Empty>) async throws -> R = {
            try $0.message
        }
    ) async throws -> R where R: Sendable {
        try await self.deleteTodo(
            request: request,
            serializer: GRPCProtobuf.ProtobufSerializer<Todos_TodoID>(),
            deserializer: GRPCProtobuf.ProtobufDeserializer<Todos_Empty>(),
            options: options,
            body
        )
    }
    
    internal func completeTodo<R>(
        request: GRPCCore.ClientRequest<Todos_TodoID>,
        options: GRPCCore.CallOptions = .defaults,
        _ body: @Sendable @escaping (GRPCCore.ClientResponse<Todos_Todo>) async throws -> R = {
            try $0.message
        }
    ) async throws -> R where R: Sendable {
        try await self.completeTodo(
            request: request,
            serializer: GRPCProtobuf.ProtobufSerializer<Todos_TodoID>(),
            deserializer: GRPCProtobuf.ProtobufDeserializer<Todos_Todo>(),
            options: options,
            body
        )
    }
}

@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Todos_TodoService.ClientProtocol {
    /// 3. 
    internal func fetchTodos<Result>(
        _ message: Todos_Empty,
        metadata: GRPCCore.Metadata = [:],
        options: GRPCCore.CallOptions = .defaults,
        onResponse handleResponse: @Sendable @escaping (GRPCCore.ClientResponse<Todos_TodoList>) async throws -> Result = {
            try $0.message
        }
    ) async throws -> Result where Result: Sendable {
        let request = GRPCCore.ClientRequest<Todos_Empty>(
            message: message,
            metadata: metadata
        )
        return try await self.fetchTodos(
            request: request,
            options: options,
            handleResponse
        )
    }
    
    /// 4. 
    internal func createTodo<Result>(
        _ message: Todos_Todo,
        metadata: GRPCCore.Metadata = [:],
        options: GRPCCore.CallOptions = .defaults,
        onResponse handleResponse: @Sendable @escaping (GRPCCore.ClientResponse<Todos_Todo>) async throws -> Result = {
            try $0.message
        }
    ) async throws -> Result where Result: Sendable {
        let request = GRPCCore.ClientRequest<Todos_Todo>(
            message: message,
            metadata: metadata
        )
        return try await self.createTodo(
            request: request,
            options: options,
            handleResponse
        )
    }
    
    /// 5. 
    internal func deleteTodo<Result>(
        _ message: Todos_TodoID,
        metadata: GRPCCore.Metadata = [:],
        options: GRPCCore.CallOptions = .defaults,
        onResponse handleResponse: @Sendable @escaping (GRPCCore.ClientResponse<Todos_Empty>) async throws -> Result = {
            try $0.message
        }
    ) async throws -> Result where Result: Sendable {
        let request = GRPCCore.ClientRequest<Todos_TodoID>(
            message: message,
            metadata: metadata
        )
        return try await self.deleteTodo(
            request: request,
            options: options,
            handleResponse
        )
    }
    
    /// 6. 
    internal func completeTodo<Result>(
        _ message: Todos_TodoID,
        metadata: GRPCCore.Metadata = [:],
        options: GRPCCore.CallOptions = .defaults,
        onResponse handleResponse: @Sendable @escaping (GRPCCore.ClientResponse<Todos_Todo>) async throws -> Result = {
            try $0.message
        }
    ) async throws -> Result where Result: Sendable {
        let request = GRPCCore.ClientRequest<Todos_TodoID>(
            message: message,
            metadata: metadata
        )
        return try await self.completeTodo(
            request: request,
            options: options,
            handleResponse
        )
    }
}

/// 2. 
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
internal struct Todos_TodoService_Client: Todos_TodoService.ClientProtocol {
    private let client: GRPCCore.GRPCClient
    
    internal init(wrapping client: GRPCCore.GRPCClient) {
        self.client = client
    }
    
    /// 3. 
    internal func fetchTodos<R>(
        request: GRPCCore.ClientRequest<Todos_Empty>,
        serializer: some GRPCCore.MessageSerializer<Todos_Empty>,
        deserializer: some GRPCCore.MessageDeserializer<Todos_TodoList>,
        options: GRPCCore.CallOptions = .defaults,
        _ body: @Sendable @escaping (GRPCCore.ClientResponse<Todos_TodoList>) async throws -> R = {
            try $0.message
        }
    ) async throws -> R where R: Sendable {
        try await self.client.unary(
            request: request,
            descriptor: Todos_TodoService.Method.FetchTodos.descriptor,
            serializer: serializer,
            deserializer: deserializer,
            options: options,
            handler: body
        )
    }
    
    /// 4. 
    internal func createTodo<R>(
        request: GRPCCore.ClientRequest<Todos_Todo>,
        serializer: some GRPCCore.MessageSerializer<Todos_Todo>,
        deserializer: some GRPCCore.MessageDeserializer<Todos_Todo>,
        options: GRPCCore.CallOptions = .defaults,
        _ body: @Sendable @escaping (GRPCCore.ClientResponse<Todos_Todo>) async throws -> R = {
            try $0.message
        }
    ) async throws -> R where R: Sendable {
        try await self.client.unary(
            request: request,
            descriptor: Todos_TodoService.Method.CreateTodo.descriptor,
            serializer: serializer,
            deserializer: deserializer,
            options: options,
            handler: body
        )
    }
    
    /// 5. 
    internal func deleteTodo<R>(
        request: GRPCCore.ClientRequest<Todos_TodoID>,
        serializer: some GRPCCore.MessageSerializer<Todos_TodoID>,
        deserializer: some GRPCCore.MessageDeserializer<Todos_Empty>,
        options: GRPCCore.CallOptions = .defaults,
        _ body: @Sendable @escaping (GRPCCore.ClientResponse<Todos_Empty>) async throws -> R = {
            try $0.message
        }
    ) async throws -> R where R: Sendable {
        try await self.client.unary(
            request: request,
            descriptor: Todos_TodoService.Method.DeleteTodo.descriptor,
            serializer: serializer,
            deserializer: deserializer,
            options: options,
            handler: body
        )
    }
    
    /// 6. 
    internal func completeTodo<R>(
        request: GRPCCore.ClientRequest<Todos_TodoID>,
        serializer: some GRPCCore.MessageSerializer<Todos_TodoID>,
        deserializer: some GRPCCore.MessageDeserializer<Todos_Todo>,
        options: GRPCCore.CallOptions = .defaults,
        _ body: @Sendable @escaping (GRPCCore.ClientResponse<Todos_Todo>) async throws -> R = {
            try $0.message
        }
    ) async throws -> R where R: Sendable {
        try await self.client.unary(
            request: request,
            descriptor: Todos_TodoService.Method.CompleteTodo.descriptor,
            serializer: serializer,
            deserializer: deserializer,
            options: options,
            handler: body
        )
    }
}
// snippet.show
actor TodoService: Todos_TodoService_ServiceProtocol {

    var todos: [Todos_Todo]
    
    init(
        todos: [Todos_Todo] = []
    ) {
        self.todos = todos
    }

    func createTodo(
        request: ServerRequest<Todos_Todo>,
        context: ServerContext
    ) async throws -> ServerResponse<Todos_Todo> {
        todos.append(request.message)
        return .init(message: request.message)
    }
    
    func fetchTodos(
        request: ServerRequest<Todos_Empty>,
        context: ServerContext
    ) async throws -> ServerResponse<Todos_TodoList> {
        var result = Todos_TodoList()
        result.todos = todos
        return .init(message: result)
    }
    
    func completeTodo(
        request: ServerRequest<Todos_TodoID>,
        context: ServerContext
    ) async throws -> ServerResponse<Todos_Todo> {
        guard
            var todo = todos.first(where: { $0.todoID == request.message.todoID })
        else {
            return .init(
                error: RPCError.init(
                    code: .notFound,
                    message: "Todo not found."
                )
            )
        }
        todo.completed = true
        todos = todos.filter { $0.todoID != request.message.todoID }
        todos.append(todo)
        return .init(message: todo)

    }
    
    func deleteTodo(
        request: ServerRequest<Todos_TodoID>,
        context: ServerContext
    ) async throws -> ServerResponse<Todos_Empty> {
        guard
            let todo = todos.first(where: { $0.todoID == request.message.todoID })
        else {
            return .init(
                error: RPCError.init(
                    code: .notFound,
                    message: "Todo not found."
                )
            )
        }
        todos = todos.filter { $0.todoID != todo.todoID }
        return .init(message: .init())
    }
}


import ArgumentParser
import GRPCNIOTransportHTTP2
import GRPCProtobuf

@main
struct Entrypoint: AsyncParsableCommand {
    
    @Option(name: .shortAndLong)
    var hostname: String = "127.0.0.1"
    
    @Option(name: .shortAndLong)
    var port: Int = 1234
    
    func run() async throws {
        // 1.
        let server = GRPCServer(
            transport: .http2NIOPosix(
                address: .ipv4(host: hostname, port: port),
                config: .defaults(transportSecurity: .plaintext)
            ),
            services: [
                // 2.
                TodoService()
            ]
        )

        // 3.
        try await withThrowingDiscardingTaskGroup { group in
            group.addTask { try await server.serve() }
            // 4.
            if let address = try await server.listeningAddress {
                print("gRPC server listening on \(address)")
            }
        }
    }
}