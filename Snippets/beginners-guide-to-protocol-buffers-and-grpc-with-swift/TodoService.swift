import ArgumentParser
// snippet.hide
import GRPCCore
import GRPCNIOTransportHTTP2
import GRPCProtobuf
import SwiftProtobuf

// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: todo_messages.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

/// todo_messages.proto

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf
        .ProtobufAPIVersionCheck
{
    struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
    typealias Version = _2
}

/// 2.
struct Todos_Empty: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// 3.
struct Todos_TodoID: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var todoID: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// 4.
struct Todos_Todo: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var todoID: String {
        get { _todoID ?? String() }
        set { _todoID = newValue }
    }
    /// Returns true if `todoID` has been explicitly set.
    var hasTodoID: Bool { self._todoID != nil }
    /// Clears the value of `todoID`. Subsequent reads from it will return its default value.
    mutating func clearTodoID() { self._todoID = nil }

    var title: String = String()

    var completed: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _todoID: String? = nil
}

/// 5.
struct Todos_TodoList: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var todos: [Todos_Todo] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "todos"

extension Todos_Empty: SwiftProtobuf.Message, SwiftProtobuf
        ._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = _protobuf_package + ".Empty"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(
        decoder: inout D
    )
        throws
    {
        // Load everything into unknown fields
        while try decoder.nextFieldNumber() != nil {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Todos_Empty, rhs: Todos_Empty) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Todos_TodoID: SwiftProtobuf.Message, SwiftProtobuf
        ._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = _protobuf_package + ".TodoID"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "todoID")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(
        decoder: inout D
    )
        throws
    {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1:
                try {
                    try decoder.decodeSingularStringField(value: &self.todoID)
                }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.todoID.isEmpty {
            try visitor.visitSingularStringField(
                value: self.todoID,
                fieldNumber: 1
            )
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Todos_TodoID, rhs: Todos_TodoID) -> Bool {
        if lhs.todoID != rhs.todoID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Todos_Todo: SwiftProtobuf.Message, SwiftProtobuf
        ._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = _protobuf_package + ".Todo"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "todoID"),
        2: .same(proto: "title"),
        3: .same(proto: "completed"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(
        decoder: inout D
    )
        throws
    {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1:
                try {
                    try decoder.decodeSingularStringField(value: &self._todoID)
                }()
            case 2:
                try {
                    try decoder.decodeSingularStringField(value: &self.title)
                }()
            case 3:
                try {
                    try decoder.decodeSingularBoolField(value: &self.completed)
                }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try {
            if let v = self._todoID {
                try visitor.visitSingularStringField(value: v, fieldNumber: 1)
            }
        }()
        if !self.title.isEmpty {
            try visitor.visitSingularStringField(
                value: self.title,
                fieldNumber: 2
            )
        }
        if self.completed != false {
            try visitor.visitSingularBoolField(
                value: self.completed,
                fieldNumber: 3
            )
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Todos_Todo, rhs: Todos_Todo) -> Bool {
        if lhs._todoID != rhs._todoID { return false }
        if lhs.title != rhs.title { return false }
        if lhs.completed != rhs.completed { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Todos_TodoList: SwiftProtobuf.Message, SwiftProtobuf
        ._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = _protobuf_package + ".TodoList"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "todos")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(
        decoder: inout D
    )
        throws
    {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1:
                try {
                    try decoder.decodeRepeatedMessageField(value: &self.todos)
                }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.todos.isEmpty {
            try visitor.visitRepeatedMessageField(
                value: self.todos,
                fieldNumber: 1
            )
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Todos_TodoList, rhs: Todos_TodoList) -> Bool {
        if lhs.todos != rhs.todos { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}
/// todo.proto

// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the gRPC Swift generator plugin for the protocol buffer compiler.
// Source: todo_service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/grpc/grpc-swift

internal enum Todos_TodoService {
    internal static let descriptor = GRPCCore.ServiceDescriptor
        .todos_TodoService
    internal enum Method {
        internal enum FetchTodos {
            internal typealias Input = Todos_Empty
            internal typealias Output = Todos_TodoList
            internal static let descriptor = GRPCCore.MethodDescriptor(
                service: Todos_TodoService.descriptor.fullyQualifiedService,
                method: "FetchTodos"
            )
        }
        internal enum CreateTodo {
            internal typealias Input = Todos_Todo
            internal typealias Output = Todos_Todo
            internal static let descriptor = GRPCCore.MethodDescriptor(
                service: Todos_TodoService.descriptor.fullyQualifiedService,
                method: "CreateTodo"
            )
        }
        internal enum DeleteTodo {
            internal typealias Input = Todos_TodoID
            internal typealias Output = Todos_Empty
            internal static let descriptor = GRPCCore.MethodDescriptor(
                service: Todos_TodoService.descriptor.fullyQualifiedService,
                method: "DeleteTodo"
            )
        }
        internal enum CompleteTodo {
            internal typealias Input = Todos_TodoID
            internal typealias Output = Todos_Todo
            internal static let descriptor = GRPCCore.MethodDescriptor(
                service: Todos_TodoService.descriptor.fullyQualifiedService,
                method: "CompleteTodo"
            )
        }
        internal static let descriptors: [GRPCCore.MethodDescriptor] = [
            FetchTodos.descriptor,
            CreateTodo.descriptor,
            DeleteTodo.descriptor,
            CompleteTodo.descriptor,
        ]
    }
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    internal typealias StreamingServiceProtocol =
        Todos_TodoService_StreamingServiceProtocol
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    internal typealias ServiceProtocol = Todos_TodoService_ServiceProtocol
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    internal typealias ClientProtocol = Todos_TodoService_ClientProtocol
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    internal typealias Client = Todos_TodoService_Client
}

extension GRPCCore.ServiceDescriptor {
    internal static let todos_TodoService = Self(
        package: "todos",
        service: "TodoService"
    )
}

/// 2.
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
internal protocol Todos_TodoService_StreamingServiceProtocol: GRPCCore
        .RegistrableRPCService
{
    /// 3.
    func fetchTodos(
        request: GRPCCore.StreamingServerRequest<Todos_Empty>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.StreamingServerResponse<Todos_TodoList>

    /// 4.
    func createTodo(
        request: GRPCCore.StreamingServerRequest<Todos_Todo>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.StreamingServerResponse<Todos_Todo>

    /// 5.
    func deleteTodo(
        request: GRPCCore.StreamingServerRequest<Todos_TodoID>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.StreamingServerResponse<Todos_Empty>

    /// 6.
    func completeTodo(
        request: GRPCCore.StreamingServerRequest<Todos_TodoID>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.StreamingServerResponse<Todos_Todo>
}

/// Conformance to `GRPCCore.RegistrableRPCService`.
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Todos_TodoService.StreamingServiceProtocol {
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    internal func registerMethods(with router: inout GRPCCore.RPCRouter) {
        router.registerHandler(
            forMethod: Todos_TodoService.Method.FetchTodos.descriptor,
            deserializer: GRPCProtobuf.ProtobufDeserializer<Todos_Empty>(),
            serializer: GRPCProtobuf.ProtobufSerializer<Todos_TodoList>(),
            handler: { request, context in
                try await self.fetchTodos(
                    request: request,
                    context: context
                )
            }
        )
        router.registerHandler(
            forMethod: Todos_TodoService.Method.CreateTodo.descriptor,
            deserializer: GRPCProtobuf.ProtobufDeserializer<Todos_Todo>(),
            serializer: GRPCProtobuf.ProtobufSerializer<Todos_Todo>(),
            handler: { request, context in
                try await self.createTodo(
                    request: request,
                    context: context
                )
            }
        )
        router.registerHandler(
            forMethod: Todos_TodoService.Method.DeleteTodo.descriptor,
            deserializer: GRPCProtobuf.ProtobufDeserializer<Todos_TodoID>(),
            serializer: GRPCProtobuf.ProtobufSerializer<Todos_Empty>(),
            handler: { request, context in
                try await self.deleteTodo(
                    request: request,
                    context: context
                )
            }
        )
        router.registerHandler(
            forMethod: Todos_TodoService.Method.CompleteTodo.descriptor,
            deserializer: GRPCProtobuf.ProtobufDeserializer<Todos_TodoID>(),
            serializer: GRPCProtobuf.ProtobufSerializer<Todos_Todo>(),
            handler: { request, context in
                try await self.completeTodo(
                    request: request,
                    context: context
                )
            }
        )
    }
}

/// 2.
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
internal protocol Todos_TodoService_ServiceProtocol: Todos_TodoService
        .StreamingServiceProtocol
{
    /// 3.
    func fetchTodos(
        request: GRPCCore.ServerRequest<Todos_Empty>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.ServerResponse<Todos_TodoList>

    /// 4.
    func createTodo(
        request: GRPCCore.ServerRequest<Todos_Todo>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.ServerResponse<Todos_Todo>

    /// 5.
    func deleteTodo(
        request: GRPCCore.ServerRequest<Todos_TodoID>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.ServerResponse<Todos_Empty>

    /// 6.
    func completeTodo(
        request: GRPCCore.ServerRequest<Todos_TodoID>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.ServerResponse<Todos_Todo>
}

/// Partial conformance to `Todos_TodoService_StreamingServiceProtocol`.
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Todos_TodoService.ServiceProtocol {
    internal func fetchTodos(
        request: GRPCCore.StreamingServerRequest<Todos_Empty>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.StreamingServerResponse<Todos_TodoList> {
        let response = try await self.fetchTodos(
            request: GRPCCore.ServerRequest(stream: request),
            context: context
        )
        return GRPCCore.StreamingServerResponse(single: response)
    }

    internal func createTodo(
        request: GRPCCore.StreamingServerRequest<Todos_Todo>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.StreamingServerResponse<Todos_Todo> {
        let response = try await self.createTodo(
            request: GRPCCore.ServerRequest(stream: request),
            context: context
        )
        return GRPCCore.StreamingServerResponse(single: response)
    }

    internal func deleteTodo(
        request: GRPCCore.StreamingServerRequest<Todos_TodoID>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.StreamingServerResponse<Todos_Empty> {
        let response = try await self.deleteTodo(
            request: GRPCCore.ServerRequest(stream: request),
            context: context
        )
        return GRPCCore.StreamingServerResponse(single: response)
    }

    internal func completeTodo(
        request: GRPCCore.StreamingServerRequest<Todos_TodoID>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.StreamingServerResponse<Todos_Todo> {
        let response = try await self.completeTodo(
            request: GRPCCore.ServerRequest(stream: request),
            context: context
        )
        return GRPCCore.StreamingServerResponse(single: response)
    }
}

/// 2.
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
internal protocol Todos_TodoService_ClientProtocol: Sendable {
    /// 3.
    func fetchTodos<R>(
        request: GRPCCore.ClientRequest<Todos_Empty>,
        serializer: some GRPCCore.MessageSerializer<Todos_Empty>,
        deserializer: some GRPCCore.MessageDeserializer<Todos_TodoList>,
        options: GRPCCore.CallOptions,
        _ body:
            @Sendable @escaping (GRPCCore.ClientResponse<Todos_TodoList>)
            async throws -> R
    ) async throws -> R where R: Sendable

    /// 4.
    func createTodo<R>(
        request: GRPCCore.ClientRequest<Todos_Todo>,
        serializer: some GRPCCore.MessageSerializer<Todos_Todo>,
        deserializer: some GRPCCore.MessageDeserializer<Todos_Todo>,
        options: GRPCCore.CallOptions,
        _ body:
            @Sendable @escaping (GRPCCore.ClientResponse<Todos_Todo>)
            async throws -> R
    ) async throws -> R where R: Sendable

    /// 5.
    func deleteTodo<R>(
        request: GRPCCore.ClientRequest<Todos_TodoID>,
        serializer: some GRPCCore.MessageSerializer<Todos_TodoID>,
        deserializer: some GRPCCore.MessageDeserializer<Todos_Empty>,
        options: GRPCCore.CallOptions,
        _ body:
            @Sendable @escaping (GRPCCore.ClientResponse<Todos_Empty>)
            async throws -> R
    ) async throws -> R where R: Sendable

    /// 6.
    func completeTodo<R>(
        request: GRPCCore.ClientRequest<Todos_TodoID>,
        serializer: some GRPCCore.MessageSerializer<Todos_TodoID>,
        deserializer: some GRPCCore.MessageDeserializer<Todos_Todo>,
        options: GRPCCore.CallOptions,
        _ body:
            @Sendable @escaping (GRPCCore.ClientResponse<Todos_Todo>)
            async throws -> R
    ) async throws -> R where R: Sendable
}

@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Todos_TodoService.ClientProtocol {
    internal func fetchTodos<R>(
        request: GRPCCore.ClientRequest<Todos_Empty>,
        options: GRPCCore.CallOptions = .defaults,
        _ body:
            @Sendable @escaping (GRPCCore.ClientResponse<Todos_TodoList>)
            async throws -> R = {
                try $0.message
            }
    ) async throws -> R where R: Sendable {
        try await self.fetchTodos(
            request: request,
            serializer: GRPCProtobuf.ProtobufSerializer<Todos_Empty>(),
            deserializer: GRPCProtobuf.ProtobufDeserializer<Todos_TodoList>(),
            options: options,
            body
        )
    }

    internal func createTodo<R>(
        request: GRPCCore.ClientRequest<Todos_Todo>,
        options: GRPCCore.CallOptions = .defaults,
        _ body:
            @Sendable @escaping (GRPCCore.ClientResponse<Todos_Todo>)
            async throws -> R = {
                try $0.message
            }
    ) async throws -> R where R: Sendable {
        try await self.createTodo(
            request: request,
            serializer: GRPCProtobuf.ProtobufSerializer<Todos_Todo>(),
            deserializer: GRPCProtobuf.ProtobufDeserializer<Todos_Todo>(),
            options: options,
            body
        )
    }

    internal func deleteTodo<R>(
        request: GRPCCore.ClientRequest<Todos_TodoID>,
        options: GRPCCore.CallOptions = .defaults,
        _ body:
            @Sendable @escaping (GRPCCore.ClientResponse<Todos_Empty>)
            async throws -> R = {
                try $0.message
            }
    ) async throws -> R where R: Sendable {
        try await self.deleteTodo(
            request: request,
            serializer: GRPCProtobuf.ProtobufSerializer<Todos_TodoID>(),
            deserializer: GRPCProtobuf.ProtobufDeserializer<Todos_Empty>(),
            options: options,
            body
        )
    }

    internal func completeTodo<R>(
        request: GRPCCore.ClientRequest<Todos_TodoID>,
        options: GRPCCore.CallOptions = .defaults,
        _ body:
            @Sendable @escaping (GRPCCore.ClientResponse<Todos_Todo>)
            async throws -> R = {
                try $0.message
            }
    ) async throws -> R where R: Sendable {
        try await self.completeTodo(
            request: request,
            serializer: GRPCProtobuf.ProtobufSerializer<Todos_TodoID>(),
            deserializer: GRPCProtobuf.ProtobufDeserializer<Todos_Todo>(),
            options: options,
            body
        )
    }
}

@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Todos_TodoService.ClientProtocol {
    /// 3.
    internal func fetchTodos<Result>(
        _ message: Todos_Empty,
        metadata: GRPCCore.Metadata = [:],
        options: GRPCCore.CallOptions = .defaults,
        onResponse handleResponse:
            @Sendable @escaping (GRPCCore.ClientResponse<Todos_TodoList>)
            async throws -> Result = {
                try $0.message
            }
    ) async throws -> Result where Result: Sendable {
        let request = GRPCCore.ClientRequest<Todos_Empty>(
            message: message,
            metadata: metadata
        )
        return try await self.fetchTodos(
            request: request,
            options: options,
            handleResponse
        )
    }

    /// 4.
    internal func createTodo<Result>(
        _ message: Todos_Todo,
        metadata: GRPCCore.Metadata = [:],
        options: GRPCCore.CallOptions = .defaults,
        onResponse handleResponse:
            @Sendable @escaping (GRPCCore.ClientResponse<Todos_Todo>)
            async throws -> Result = {
                try $0.message
            }
    ) async throws -> Result where Result: Sendable {
        let request = GRPCCore.ClientRequest<Todos_Todo>(
            message: message,
            metadata: metadata
        )
        return try await self.createTodo(
            request: request,
            options: options,
            handleResponse
        )
    }

    /// 5.
    internal func deleteTodo<Result>(
        _ message: Todos_TodoID,
        metadata: GRPCCore.Metadata = [:],
        options: GRPCCore.CallOptions = .defaults,
        onResponse handleResponse:
            @Sendable @escaping (GRPCCore.ClientResponse<Todos_Empty>)
            async throws -> Result = {
                try $0.message
            }
    ) async throws -> Result where Result: Sendable {
        let request = GRPCCore.ClientRequest<Todos_TodoID>(
            message: message,
            metadata: metadata
        )
        return try await self.deleteTodo(
            request: request,
            options: options,
            handleResponse
        )
    }

    /// 6.
    internal func completeTodo<Result>(
        _ message: Todos_TodoID,
        metadata: GRPCCore.Metadata = [:],
        options: GRPCCore.CallOptions = .defaults,
        onResponse handleResponse:
            @Sendable @escaping (GRPCCore.ClientResponse<Todos_Todo>)
            async throws -> Result = {
                try $0.message
            }
    ) async throws -> Result where Result: Sendable {
        let request = GRPCCore.ClientRequest<Todos_TodoID>(
            message: message,
            metadata: metadata
        )
        return try await self.completeTodo(
            request: request,
            options: options,
            handleResponse
        )
    }
}

/// 2.
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
internal struct Todos_TodoService_Client: Todos_TodoService.ClientProtocol {
    private let client: GRPCCore.GRPCClient

    internal init(wrapping client: GRPCCore.GRPCClient) {
        self.client = client
    }

    /// 3.
    internal func fetchTodos<R>(
        request: GRPCCore.ClientRequest<Todos_Empty>,
        serializer: some GRPCCore.MessageSerializer<Todos_Empty>,
        deserializer: some GRPCCore.MessageDeserializer<Todos_TodoList>,
        options: GRPCCore.CallOptions = .defaults,
        _ body:
            @Sendable @escaping (GRPCCore.ClientResponse<Todos_TodoList>)
            async throws -> R = {
                try $0.message
            }
    ) async throws -> R where R: Sendable {
        try await self.client.unary(
            request: request,
            descriptor: Todos_TodoService.Method.FetchTodos.descriptor,
            serializer: serializer,
            deserializer: deserializer,
            options: options,
            handler: body
        )
    }

    /// 4.
    internal func createTodo<R>(
        request: GRPCCore.ClientRequest<Todos_Todo>,
        serializer: some GRPCCore.MessageSerializer<Todos_Todo>,
        deserializer: some GRPCCore.MessageDeserializer<Todos_Todo>,
        options: GRPCCore.CallOptions = .defaults,
        _ body:
            @Sendable @escaping (GRPCCore.ClientResponse<Todos_Todo>)
            async throws -> R = {
                try $0.message
            }
    ) async throws -> R where R: Sendable {
        try await self.client.unary(
            request: request,
            descriptor: Todos_TodoService.Method.CreateTodo.descriptor,
            serializer: serializer,
            deserializer: deserializer,
            options: options,
            handler: body
        )
    }

    /// 5.
    internal func deleteTodo<R>(
        request: GRPCCore.ClientRequest<Todos_TodoID>,
        serializer: some GRPCCore.MessageSerializer<Todos_TodoID>,
        deserializer: some GRPCCore.MessageDeserializer<Todos_Empty>,
        options: GRPCCore.CallOptions = .defaults,
        _ body:
            @Sendable @escaping (GRPCCore.ClientResponse<Todos_Empty>)
            async throws -> R = {
                try $0.message
            }
    ) async throws -> R where R: Sendable {
        try await self.client.unary(
            request: request,
            descriptor: Todos_TodoService.Method.DeleteTodo.descriptor,
            serializer: serializer,
            deserializer: deserializer,
            options: options,
            handler: body
        )
    }

    /// 6.
    internal func completeTodo<R>(
        request: GRPCCore.ClientRequest<Todos_TodoID>,
        serializer: some GRPCCore.MessageSerializer<Todos_TodoID>,
        deserializer: some GRPCCore.MessageDeserializer<Todos_Todo>,
        options: GRPCCore.CallOptions = .defaults,
        _ body:
            @Sendable @escaping (GRPCCore.ClientResponse<Todos_Todo>)
            async throws -> R = {
                try $0.message
            }
    ) async throws -> R where R: Sendable {
        try await self.client.unary(
            request: request,
            descriptor: Todos_TodoService.Method.CompleteTodo.descriptor,
            serializer: serializer,
            deserializer: deserializer,
            options: options,
            handler: body
        )
    }
}
// snippet.show
actor TodoService: Todos_TodoService_ServiceProtocol {

    var todos: [Todos_Todo]

    init(
        todos: [Todos_Todo] = []
    ) {
        self.todos = todos
    }

    func createTodo(
        request: ServerRequest<Todos_Todo>,
        context: ServerContext
    ) async throws -> ServerResponse<Todos_Todo> {
        todos.append(request.message)
        return .init(message: request.message)
    }

    func fetchTodos(
        request: ServerRequest<Todos_Empty>,
        context: ServerContext
    ) async throws -> ServerResponse<Todos_TodoList> {
        var result = Todos_TodoList()
        result.todos = todos
        return .init(message: result)
    }

    func completeTodo(
        request: ServerRequest<Todos_TodoID>,
        context: ServerContext
    ) async throws -> ServerResponse<Todos_Todo> {
        guard
            var todo = todos.first(where: {
                $0.todoID == request.message.todoID
            })
        else {
            return .init(
                error: RPCError.init(
                    code: .notFound,
                    message: "Todo not found."
                )
            )
        }
        todo.completed = true
        todos = todos.filter { $0.todoID != request.message.todoID }
        todos.append(todo)
        return .init(message: todo)

    }

    func deleteTodo(
        request: ServerRequest<Todos_TodoID>,
        context: ServerContext
    ) async throws -> ServerResponse<Todos_Empty> {
        guard
            let todo = todos.first(where: {
                $0.todoID == request.message.todoID
            })
        else {
            return .init(
                error: RPCError.init(
                    code: .notFound,
                    message: "Todo not found."
                )
            )
        }
        todos = todos.filter { $0.todoID != todo.todoID }
        return .init(message: .init())
    }
}

@main
struct Entrypoint: AsyncParsableCommand {

    @Option(name: .shortAndLong)
    var hostname: String = "127.0.0.1"

    @Option(name: .shortAndLong)
    var port: Int = 1234

    func run() async throws {
        // 1.
        let server = GRPCServer(
            transport: .http2NIOPosix(
                address: .ipv4(host: hostname, port: port),
                config: .defaults(transportSecurity: .plaintext)
            ),
            services: [
                // 2.
                TodoService()
            ]
        )

        // 3.
        try await withThrowingDiscardingTaskGroup { group in
            group.addTask { try await server.serve() }
            // 4.
            if let address = try await server.listeningAddress {
                print("gRPC server listening on \(address)")
            }
        }
    }
}
