import GRPCNIOTransportHTTP2
import GRPCProtobuf

// snippet.hide
// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: todo_messages.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// 2.
struct Todos_Empty: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 3.
struct Todos_TodoID: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var todoID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 4.
struct Todos_Todo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var todoID: String {
    get {return _todoID ?? String()}
    set {_todoID = newValue}
  }
  /// Returns true if `todoID` has been explicitly set.
  var hasTodoID: Bool {return self._todoID != nil}
  /// Clears the value of `todoID`. Subsequent reads from it will return its default value.
  mutating func clearTodoID() {self._todoID = nil}

  var title: String = String()

  var completed: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _todoID: String? = nil
}

/// 5.
struct Todos_TodoList: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var todos: [Todos_Todo] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "todos"

extension Todos_Empty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Empty"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Todos_Empty, rhs: Todos_Empty) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Todos_TodoID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TodoID"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "todoID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.todoID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.todoID.isEmpty {
      try visitor.visitSingularStringField(value: self.todoID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Todos_TodoID, rhs: Todos_TodoID) -> Bool {
    if lhs.todoID != rhs.todoID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Todos_Todo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Todo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "todoID"),
    2: .same(proto: "title"),
    3: .same(proto: "completed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._todoID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.completed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._todoID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if self.completed != false {
      try visitor.visitSingularBoolField(value: self.completed, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Todos_Todo, rhs: Todos_Todo) -> Bool {
    if lhs._todoID != rhs._todoID {return false}
    if lhs.title != rhs.title {return false}
    if lhs.completed != rhs.completed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Todos_TodoList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TodoList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "todos"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.todos) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.todos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.todos, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Todos_TodoList, rhs: Todos_TodoList) -> Bool {
    if lhs.todos != rhs.todos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the gRPC Swift generator plugin for the protocol buffer compiler.
// Source: todo_service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/grpc/grpc-swift

import GRPCCore
import GRPCProtobuf

// MARK: - todos.TodoService

/// Namespace containing generated types for the "todos.TodoService" service.
internal enum Todos_TodoService {
    /// Service descriptor for the "todos.TodoService" service.
    internal static let descriptor = GRPCCore.ServiceDescriptor(fullyQualifiedService: "todos.TodoService")
    /// Namespace for method metadata.
    internal enum Method {
        /// Namespace for "FetchTodos" metadata.
        internal enum FetchTodos {
            /// Request type for "FetchTodos".
            internal typealias Input = Todos_Empty
            /// Response type for "FetchTodos".
            internal typealias Output = Todos_TodoList
            /// Descriptor for "FetchTodos".
            internal static let descriptor = GRPCCore.MethodDescriptor(
                service: GRPCCore.ServiceDescriptor(fullyQualifiedService: "todos.TodoService"),
                method: "FetchTodos"
            )
        }
        /// Namespace for "CreateTodo" metadata.
        internal enum CreateTodo {
            /// Request type for "CreateTodo".
            internal typealias Input = Todos_Todo
            /// Response type for "CreateTodo".
            internal typealias Output = Todos_Todo
            /// Descriptor for "CreateTodo".
            internal static let descriptor = GRPCCore.MethodDescriptor(
                service: GRPCCore.ServiceDescriptor(fullyQualifiedService: "todos.TodoService"),
                method: "CreateTodo"
            )
        }
        /// Namespace for "DeleteTodo" metadata.
        internal enum DeleteTodo {
            /// Request type for "DeleteTodo".
            internal typealias Input = Todos_TodoID
            /// Response type for "DeleteTodo".
            internal typealias Output = Todos_Empty
            /// Descriptor for "DeleteTodo".
            internal static let descriptor = GRPCCore.MethodDescriptor(
                service: GRPCCore.ServiceDescriptor(fullyQualifiedService: "todos.TodoService"),
                method: "DeleteTodo"
            )
        }
        /// Namespace for "CompleteTodo" metadata.
        internal enum CompleteTodo {
            /// Request type for "CompleteTodo".
            internal typealias Input = Todos_TodoID
            /// Response type for "CompleteTodo".
            internal typealias Output = Todos_Todo
            /// Descriptor for "CompleteTodo".
            internal static let descriptor = GRPCCore.MethodDescriptor(
                service: GRPCCore.ServiceDescriptor(fullyQualifiedService: "todos.TodoService"),
                method: "CompleteTodo"
            )
        }
        /// Descriptors for all methods in the "todos.TodoService" service.
        internal static let descriptors: [GRPCCore.MethodDescriptor] = [
            FetchTodos.descriptor,
            CreateTodo.descriptor,
            DeleteTodo.descriptor,
            CompleteTodo.descriptor
        ]
    }
}

extension GRPCCore.ServiceDescriptor {
    /// Service descriptor for the "todos.TodoService" service.
    internal static let todos_TodoService = GRPCCore.ServiceDescriptor(fullyQualifiedService: "todos.TodoService")
}

// MARK: todos.TodoService (server)

extension Todos_TodoService {
    /// Streaming variant of the service protocol for the "todos.TodoService" service.
    ///
    /// This protocol is the lowest-level of the service protocols generated for this service
    /// giving you the most flexibility over the implementation of your service. This comes at
    /// the cost of more verbose and less strict APIs. Each RPC requires you to implement it in
    /// terms of a request stream and response stream. Where only a single request or response
    /// message is expected, you are responsible for enforcing this invariant is maintained.
    ///
    /// Where possible, prefer using the stricter, less-verbose ``ServiceProtocol``
    /// or ``SimpleServiceProtocol`` instead.
    ///
    /// > Source IDL Documentation:
    /// >
    /// > 2.
    internal protocol StreamingServiceProtocol: GRPCCore.RegistrableRPCService {
        /// Handle the "FetchTodos" method.
        ///
        /// > Source IDL Documentation:
        /// >
        /// > 3.
        ///
        /// - Parameters:
        ///   - request: A streaming request of `Todos_Empty` messages.
        ///   - context: Context providing information about the RPC.
        /// - Throws: Any error which occurred during the processing of the request. Thrown errors
        ///     of type `RPCError` are mapped to appropriate statuses. All other errors are converted
        ///     to an internal error.
        /// - Returns: A streaming response of `Todos_TodoList` messages.
        func fetchTodos(
            request: GRPCCore.StreamingServerRequest<Todos_Empty>,
            context: GRPCCore.ServerContext
        ) async throws -> GRPCCore.StreamingServerResponse<Todos_TodoList>

        /// Handle the "CreateTodo" method.
        ///
        /// > Source IDL Documentation:
        /// >
        /// > 4.
        ///
        /// - Parameters:
        ///   - request: A streaming request of `Todos_Todo` messages.
        ///   - context: Context providing information about the RPC.
        /// - Throws: Any error which occurred during the processing of the request. Thrown errors
        ///     of type `RPCError` are mapped to appropriate statuses. All other errors are converted
        ///     to an internal error.
        /// - Returns: A streaming response of `Todos_Todo` messages.
        func createTodo(
            request: GRPCCore.StreamingServerRequest<Todos_Todo>,
            context: GRPCCore.ServerContext
        ) async throws -> GRPCCore.StreamingServerResponse<Todos_Todo>

        /// Handle the "DeleteTodo" method.
        ///
        /// > Source IDL Documentation:
        /// >
        /// > 5.
        ///
        /// - Parameters:
        ///   - request: A streaming request of `Todos_TodoID` messages.
        ///   - context: Context providing information about the RPC.
        /// - Throws: Any error which occurred during the processing of the request. Thrown errors
        ///     of type `RPCError` are mapped to appropriate statuses. All other errors are converted
        ///     to an internal error.
        /// - Returns: A streaming response of `Todos_Empty` messages.
        func deleteTodo(
            request: GRPCCore.StreamingServerRequest<Todos_TodoID>,
            context: GRPCCore.ServerContext
        ) async throws -> GRPCCore.StreamingServerResponse<Todos_Empty>

        /// Handle the "CompleteTodo" method.
        ///
        /// > Source IDL Documentation:
        /// >
        /// > 6.
        ///
        /// - Parameters:
        ///   - request: A streaming request of `Todos_TodoID` messages.
        ///   - context: Context providing information about the RPC.
        /// - Throws: Any error which occurred during the processing of the request. Thrown errors
        ///     of type `RPCError` are mapped to appropriate statuses. All other errors are converted
        ///     to an internal error.
        /// - Returns: A streaming response of `Todos_Todo` messages.
        func completeTodo(
            request: GRPCCore.StreamingServerRequest<Todos_TodoID>,
            context: GRPCCore.ServerContext
        ) async throws -> GRPCCore.StreamingServerResponse<Todos_Todo>
    }

    /// Service protocol for the "todos.TodoService" service.
    ///
    /// This protocol is higher level than ``StreamingServiceProtocol`` but lower level than
    /// the ``SimpleServiceProtocol``, it provides access to request and response metadata and
    /// trailing response metadata. If you don't need these then consider using
    /// the ``SimpleServiceProtocol``. If you need fine grained control over your RPCs then
    /// use ``StreamingServiceProtocol``.
    ///
    /// > Source IDL Documentation:
    /// >
    /// > 2.
    internal protocol ServiceProtocol: Todos_TodoService.StreamingServiceProtocol {
        /// Handle the "FetchTodos" method.
        ///
        /// > Source IDL Documentation:
        /// >
        /// > 3.
        ///
        /// - Parameters:
        ///   - request: A request containing a single `Todos_Empty` message.
        ///   - context: Context providing information about the RPC.
        /// - Throws: Any error which occurred during the processing of the request. Thrown errors
        ///     of type `RPCError` are mapped to appropriate statuses. All other errors are converted
        ///     to an internal error.
        /// - Returns: A response containing a single `Todos_TodoList` message.
        func fetchTodos(
            request: GRPCCore.ServerRequest<Todos_Empty>,
            context: GRPCCore.ServerContext
        ) async throws -> GRPCCore.ServerResponse<Todos_TodoList>

        /// Handle the "CreateTodo" method.
        ///
        /// > Source IDL Documentation:
        /// >
        /// > 4.
        ///
        /// - Parameters:
        ///   - request: A request containing a single `Todos_Todo` message.
        ///   - context: Context providing information about the RPC.
        /// - Throws: Any error which occurred during the processing of the request. Thrown errors
        ///     of type `RPCError` are mapped to appropriate statuses. All other errors are converted
        ///     to an internal error.
        /// - Returns: A response containing a single `Todos_Todo` message.
        func createTodo(
            request: GRPCCore.ServerRequest<Todos_Todo>,
            context: GRPCCore.ServerContext
        ) async throws -> GRPCCore.ServerResponse<Todos_Todo>

        /// Handle the "DeleteTodo" method.
        ///
        /// > Source IDL Documentation:
        /// >
        /// > 5.
        ///
        /// - Parameters:
        ///   - request: A request containing a single `Todos_TodoID` message.
        ///   - context: Context providing information about the RPC.
        /// - Throws: Any error which occurred during the processing of the request. Thrown errors
        ///     of type `RPCError` are mapped to appropriate statuses. All other errors are converted
        ///     to an internal error.
        /// - Returns: A response containing a single `Todos_Empty` message.
        func deleteTodo(
            request: GRPCCore.ServerRequest<Todos_TodoID>,
            context: GRPCCore.ServerContext
        ) async throws -> GRPCCore.ServerResponse<Todos_Empty>

        /// Handle the "CompleteTodo" method.
        ///
        /// > Source IDL Documentation:
        /// >
        /// > 6.
        ///
        /// - Parameters:
        ///   - request: A request containing a single `Todos_TodoID` message.
        ///   - context: Context providing information about the RPC.
        /// - Throws: Any error which occurred during the processing of the request. Thrown errors
        ///     of type `RPCError` are mapped to appropriate statuses. All other errors are converted
        ///     to an internal error.
        /// - Returns: A response containing a single `Todos_Todo` message.
        func completeTodo(
            request: GRPCCore.ServerRequest<Todos_TodoID>,
            context: GRPCCore.ServerContext
        ) async throws -> GRPCCore.ServerResponse<Todos_Todo>
    }

    /// Simple service protocol for the "todos.TodoService" service.
    ///
    /// This is the highest level protocol for the service. The API is the easiest to use but
    /// doesn't provide access to request or response metadata. If you need access to these
    /// then use ``ServiceProtocol`` instead.
    ///
    /// > Source IDL Documentation:
    /// >
    /// > 2.
    internal protocol SimpleServiceProtocol: Todos_TodoService.ServiceProtocol {
        /// Handle the "FetchTodos" method.
        ///
        /// > Source IDL Documentation:
        /// >
        /// > 3.
        ///
        /// - Parameters:
        ///   - request: A `Todos_Empty` message.
        ///   - context: Context providing information about the RPC.
        /// - Throws: Any error which occurred during the processing of the request. Thrown errors
        ///     of type `RPCError` are mapped to appropriate statuses. All other errors are converted
        ///     to an internal error.
        /// - Returns: A `Todos_TodoList` to respond with.
        func fetchTodos(
            request: Todos_Empty,
            context: GRPCCore.ServerContext
        ) async throws -> Todos_TodoList

        /// Handle the "CreateTodo" method.
        ///
        /// > Source IDL Documentation:
        /// >
        /// > 4.
        ///
        /// - Parameters:
        ///   - request: A `Todos_Todo` message.
        ///   - context: Context providing information about the RPC.
        /// - Throws: Any error which occurred during the processing of the request. Thrown errors
        ///     of type `RPCError` are mapped to appropriate statuses. All other errors are converted
        ///     to an internal error.
        /// - Returns: A `Todos_Todo` to respond with.
        func createTodo(
            request: Todos_Todo,
            context: GRPCCore.ServerContext
        ) async throws -> Todos_Todo

        /// Handle the "DeleteTodo" method.
        ///
        /// > Source IDL Documentation:
        /// >
        /// > 5.
        ///
        /// - Parameters:
        ///   - request: A `Todos_TodoID` message.
        ///   - context: Context providing information about the RPC.
        /// - Throws: Any error which occurred during the processing of the request. Thrown errors
        ///     of type `RPCError` are mapped to appropriate statuses. All other errors are converted
        ///     to an internal error.
        /// - Returns: A `Todos_Empty` to respond with.
        func deleteTodo(
            request: Todos_TodoID,
            context: GRPCCore.ServerContext
        ) async throws -> Todos_Empty

        /// Handle the "CompleteTodo" method.
        ///
        /// > Source IDL Documentation:
        /// >
        /// > 6.
        ///
        /// - Parameters:
        ///   - request: A `Todos_TodoID` message.
        ///   - context: Context providing information about the RPC.
        /// - Throws: Any error which occurred during the processing of the request. Thrown errors
        ///     of type `RPCError` are mapped to appropriate statuses. All other errors are converted
        ///     to an internal error.
        /// - Returns: A `Todos_Todo` to respond with.
        func completeTodo(
            request: Todos_TodoID,
            context: GRPCCore.ServerContext
        ) async throws -> Todos_Todo
    }
}

// Default implementation of 'registerMethods(with:)'.
extension Todos_TodoService.StreamingServiceProtocol {
    internal func registerMethods(with router: inout GRPCCore.RPCRouter) {
        router.registerHandler(
            forMethod: Todos_TodoService.Method.FetchTodos.descriptor,
            deserializer: GRPCProtobuf.ProtobufDeserializer<Todos_Empty>(),
            serializer: GRPCProtobuf.ProtobufSerializer<Todos_TodoList>(),
            handler: { request, context in
                try await self.fetchTodos(
                    request: request,
                    context: context
                )
            }
        )
        router.registerHandler(
            forMethod: Todos_TodoService.Method.CreateTodo.descriptor,
            deserializer: GRPCProtobuf.ProtobufDeserializer<Todos_Todo>(),
            serializer: GRPCProtobuf.ProtobufSerializer<Todos_Todo>(),
            handler: { request, context in
                try await self.createTodo(
                    request: request,
                    context: context
                )
            }
        )
        router.registerHandler(
            forMethod: Todos_TodoService.Method.DeleteTodo.descriptor,
            deserializer: GRPCProtobuf.ProtobufDeserializer<Todos_TodoID>(),
            serializer: GRPCProtobuf.ProtobufSerializer<Todos_Empty>(),
            handler: { request, context in
                try await self.deleteTodo(
                    request: request,
                    context: context
                )
            }
        )
        router.registerHandler(
            forMethod: Todos_TodoService.Method.CompleteTodo.descriptor,
            deserializer: GRPCProtobuf.ProtobufDeserializer<Todos_TodoID>(),
            serializer: GRPCProtobuf.ProtobufSerializer<Todos_Todo>(),
            handler: { request, context in
                try await self.completeTodo(
                    request: request,
                    context: context
                )
            }
        )
    }
}

// Default implementation of streaming methods from 'StreamingServiceProtocol'.
extension Todos_TodoService.ServiceProtocol {
    internal func fetchTodos(
        request: GRPCCore.StreamingServerRequest<Todos_Empty>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.StreamingServerResponse<Todos_TodoList> {
        let response = try await self.fetchTodos(
            request: GRPCCore.ServerRequest(stream: request),
            context: context
        )
        return GRPCCore.StreamingServerResponse(single: response)
    }

    internal func createTodo(
        request: GRPCCore.StreamingServerRequest<Todos_Todo>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.StreamingServerResponse<Todos_Todo> {
        let response = try await self.createTodo(
            request: GRPCCore.ServerRequest(stream: request),
            context: context
        )
        return GRPCCore.StreamingServerResponse(single: response)
    }

    internal func deleteTodo(
        request: GRPCCore.StreamingServerRequest<Todos_TodoID>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.StreamingServerResponse<Todos_Empty> {
        let response = try await self.deleteTodo(
            request: GRPCCore.ServerRequest(stream: request),
            context: context
        )
        return GRPCCore.StreamingServerResponse(single: response)
    }

    internal func completeTodo(
        request: GRPCCore.StreamingServerRequest<Todos_TodoID>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.StreamingServerResponse<Todos_Todo> {
        let response = try await self.completeTodo(
            request: GRPCCore.ServerRequest(stream: request),
            context: context
        )
        return GRPCCore.StreamingServerResponse(single: response)
    }
}

// Default implementation of methods from 'ServiceProtocol'.
extension Todos_TodoService.SimpleServiceProtocol {
    internal func fetchTodos(
        request: GRPCCore.ServerRequest<Todos_Empty>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.ServerResponse<Todos_TodoList> {
        return GRPCCore.ServerResponse<Todos_TodoList>(
            message: try await self.fetchTodos(
                request: request.message,
                context: context
            ),
            metadata: [:]
        )
    }

    internal func createTodo(
        request: GRPCCore.ServerRequest<Todos_Todo>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.ServerResponse<Todos_Todo> {
        return GRPCCore.ServerResponse<Todos_Todo>(
            message: try await self.createTodo(
                request: request.message,
                context: context
            ),
            metadata: [:]
        )
    }

    internal func deleteTodo(
        request: GRPCCore.ServerRequest<Todos_TodoID>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.ServerResponse<Todos_Empty> {
        return GRPCCore.ServerResponse<Todos_Empty>(
            message: try await self.deleteTodo(
                request: request.message,
                context: context
            ),
            metadata: [:]
        )
    }

    internal func completeTodo(
        request: GRPCCore.ServerRequest<Todos_TodoID>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.ServerResponse<Todos_Todo> {
        return GRPCCore.ServerResponse<Todos_Todo>(
            message: try await self.completeTodo(
                request: request.message,
                context: context
            ),
            metadata: [:]
        )
    }
}

// MARK: todos.TodoService (client)

extension Todos_TodoService {
    /// Generated client protocol for the "todos.TodoService" service.
    ///
    /// You don't need to implement this protocol directly, use the generated
    /// implementation, ``Client``.
    ///
    /// > Source IDL Documentation:
    /// >
    /// > 2.
    internal protocol ClientProtocol: Sendable {
        /// Call the "FetchTodos" method.
        ///
        /// > Source IDL Documentation:
        /// >
        /// > 3.
        ///
        /// - Parameters:
        ///   - request: A request containing a single `Todos_Empty` message.
        ///   - serializer: A serializer for `Todos_Empty` messages.
        ///   - deserializer: A deserializer for `Todos_TodoList` messages.
        ///   - options: Options to apply to this RPC.
        ///   - handleResponse: A closure which handles the response, the result of which is
        ///       returned to the caller. Returning from the closure will cancel the RPC if it
        ///       hasn't already finished.
        /// - Returns: The result of `handleResponse`.
        func fetchTodos<Result>(
            request: GRPCCore.ClientRequest<Todos_Empty>,
            serializer: some GRPCCore.MessageSerializer<Todos_Empty>,
            deserializer: some GRPCCore.MessageDeserializer<Todos_TodoList>,
            options: GRPCCore.CallOptions,
            onResponse handleResponse: @Sendable @escaping (GRPCCore.ClientResponse<Todos_TodoList>) async throws -> Result
        ) async throws -> Result where Result: Sendable

        /// Call the "CreateTodo" method.
        ///
        /// > Source IDL Documentation:
        /// >
        /// > 4.
        ///
        /// - Parameters:
        ///   - request: A request containing a single `Todos_Todo` message.
        ///   - serializer: A serializer for `Todos_Todo` messages.
        ///   - deserializer: A deserializer for `Todos_Todo` messages.
        ///   - options: Options to apply to this RPC.
        ///   - handleResponse: A closure which handles the response, the result of which is
        ///       returned to the caller. Returning from the closure will cancel the RPC if it
        ///       hasn't already finished.
        /// - Returns: The result of `handleResponse`.
        func createTodo<Result>(
            request: GRPCCore.ClientRequest<Todos_Todo>,
            serializer: some GRPCCore.MessageSerializer<Todos_Todo>,
            deserializer: some GRPCCore.MessageDeserializer<Todos_Todo>,
            options: GRPCCore.CallOptions,
            onResponse handleResponse: @Sendable @escaping (GRPCCore.ClientResponse<Todos_Todo>) async throws -> Result
        ) async throws -> Result where Result: Sendable

        /// Call the "DeleteTodo" method.
        ///
        /// > Source IDL Documentation:
        /// >
        /// > 5.
        ///
        /// - Parameters:
        ///   - request: A request containing a single `Todos_TodoID` message.
        ///   - serializer: A serializer for `Todos_TodoID` messages.
        ///   - deserializer: A deserializer for `Todos_Empty` messages.
        ///   - options: Options to apply to this RPC.
        ///   - handleResponse: A closure which handles the response, the result of which is
        ///       returned to the caller. Returning from the closure will cancel the RPC if it
        ///       hasn't already finished.
        /// - Returns: The result of `handleResponse`.
        func deleteTodo<Result>(
            request: GRPCCore.ClientRequest<Todos_TodoID>,
            serializer: some GRPCCore.MessageSerializer<Todos_TodoID>,
            deserializer: some GRPCCore.MessageDeserializer<Todos_Empty>,
            options: GRPCCore.CallOptions,
            onResponse handleResponse: @Sendable @escaping (GRPCCore.ClientResponse<Todos_Empty>) async throws -> Result
        ) async throws -> Result where Result: Sendable

        /// Call the "CompleteTodo" method.
        ///
        /// > Source IDL Documentation:
        /// >
        /// > 6.
        ///
        /// - Parameters:
        ///   - request: A request containing a single `Todos_TodoID` message.
        ///   - serializer: A serializer for `Todos_TodoID` messages.
        ///   - deserializer: A deserializer for `Todos_Todo` messages.
        ///   - options: Options to apply to this RPC.
        ///   - handleResponse: A closure which handles the response, the result of which is
        ///       returned to the caller. Returning from the closure will cancel the RPC if it
        ///       hasn't already finished.
        /// - Returns: The result of `handleResponse`.
        func completeTodo<Result>(
            request: GRPCCore.ClientRequest<Todos_TodoID>,
            serializer: some GRPCCore.MessageSerializer<Todos_TodoID>,
            deserializer: some GRPCCore.MessageDeserializer<Todos_Todo>,
            options: GRPCCore.CallOptions,
            onResponse handleResponse: @Sendable @escaping (GRPCCore.ClientResponse<Todos_Todo>) async throws -> Result
        ) async throws -> Result where Result: Sendable
    }

    /// Generated client for the "todos.TodoService" service.
    ///
    /// The ``Client`` provides an implementation of ``ClientProtocol`` which wraps
    /// a `GRPCCore.GRPCCClient`. The underlying `GRPCClient` provides the long-lived
    /// means of communication with the remote peer.
    ///
    /// > Source IDL Documentation:
    /// >
    /// > 2.
    internal struct Client: ClientProtocol {
        private let client: GRPCCore.GRPCClient

        /// Creates a new client wrapping the provided `GRPCCore.GRPCClient`.
        ///
        /// - Parameters:
        ///   - client: A `GRPCCore.GRPCClient` providing a communication channel to the service.
        internal init(wrapping client: GRPCCore.GRPCClient) {
            self.client = client
        }

        /// Call the "FetchTodos" method.
        ///
        /// > Source IDL Documentation:
        /// >
        /// > 3.
        ///
        /// - Parameters:
        ///   - request: A request containing a single `Todos_Empty` message.
        ///   - serializer: A serializer for `Todos_Empty` messages.
        ///   - deserializer: A deserializer for `Todos_TodoList` messages.
        ///   - options: Options to apply to this RPC.
        ///   - handleResponse: A closure which handles the response, the result of which is
        ///       returned to the caller. Returning from the closure will cancel the RPC if it
        ///       hasn't already finished.
        /// - Returns: The result of `handleResponse`.
        internal func fetchTodos<Result>(
            request: GRPCCore.ClientRequest<Todos_Empty>,
            serializer: some GRPCCore.MessageSerializer<Todos_Empty>,
            deserializer: some GRPCCore.MessageDeserializer<Todos_TodoList>,
            options: GRPCCore.CallOptions = .defaults,
            onResponse handleResponse: @Sendable @escaping (GRPCCore.ClientResponse<Todos_TodoList>) async throws -> Result = { response in
                try response.message
            }
        ) async throws -> Result where Result: Sendable {
            try await self.client.unary(
                request: request,
                descriptor: Todos_TodoService.Method.FetchTodos.descriptor,
                serializer: serializer,
                deserializer: deserializer,
                options: options,
                onResponse: handleResponse
            )
        }

        /// Call the "CreateTodo" method.
        ///
        /// > Source IDL Documentation:
        /// >
        /// > 4.
        ///
        /// - Parameters:
        ///   - request: A request containing a single `Todos_Todo` message.
        ///   - serializer: A serializer for `Todos_Todo` messages.
        ///   - deserializer: A deserializer for `Todos_Todo` messages.
        ///   - options: Options to apply to this RPC.
        ///   - handleResponse: A closure which handles the response, the result of which is
        ///       returned to the caller. Returning from the closure will cancel the RPC if it
        ///       hasn't already finished.
        /// - Returns: The result of `handleResponse`.
        internal func createTodo<Result>(
            request: GRPCCore.ClientRequest<Todos_Todo>,
            serializer: some GRPCCore.MessageSerializer<Todos_Todo>,
            deserializer: some GRPCCore.MessageDeserializer<Todos_Todo>,
            options: GRPCCore.CallOptions = .defaults,
            onResponse handleResponse: @Sendable @escaping (GRPCCore.ClientResponse<Todos_Todo>) async throws -> Result = { response in
                try response.message
            }
        ) async throws -> Result where Result: Sendable {
            try await self.client.unary(
                request: request,
                descriptor: Todos_TodoService.Method.CreateTodo.descriptor,
                serializer: serializer,
                deserializer: deserializer,
                options: options,
                onResponse: handleResponse
            )
        }

        /// Call the "DeleteTodo" method.
        ///
        /// > Source IDL Documentation:
        /// >
        /// > 5.
        ///
        /// - Parameters:
        ///   - request: A request containing a single `Todos_TodoID` message.
        ///   - serializer: A serializer for `Todos_TodoID` messages.
        ///   - deserializer: A deserializer for `Todos_Empty` messages.
        ///   - options: Options to apply to this RPC.
        ///   - handleResponse: A closure which handles the response, the result of which is
        ///       returned to the caller. Returning from the closure will cancel the RPC if it
        ///       hasn't already finished.
        /// - Returns: The result of `handleResponse`.
        internal func deleteTodo<Result>(
            request: GRPCCore.ClientRequest<Todos_TodoID>,
            serializer: some GRPCCore.MessageSerializer<Todos_TodoID>,
            deserializer: some GRPCCore.MessageDeserializer<Todos_Empty>,
            options: GRPCCore.CallOptions = .defaults,
            onResponse handleResponse: @Sendable @escaping (GRPCCore.ClientResponse<Todos_Empty>) async throws -> Result = { response in
                try response.message
            }
        ) async throws -> Result where Result: Sendable {
            try await self.client.unary(
                request: request,
                descriptor: Todos_TodoService.Method.DeleteTodo.descriptor,
                serializer: serializer,
                deserializer: deserializer,
                options: options,
                onResponse: handleResponse
            )
        }

        /// Call the "CompleteTodo" method.
        ///
        /// > Source IDL Documentation:
        /// >
        /// > 6.
        ///
        /// - Parameters:
        ///   - request: A request containing a single `Todos_TodoID` message.
        ///   - serializer: A serializer for `Todos_TodoID` messages.
        ///   - deserializer: A deserializer for `Todos_Todo` messages.
        ///   - options: Options to apply to this RPC.
        ///   - handleResponse: A closure which handles the response, the result of which is
        ///       returned to the caller. Returning from the closure will cancel the RPC if it
        ///       hasn't already finished.
        /// - Returns: The result of `handleResponse`.
        internal func completeTodo<Result>(
            request: GRPCCore.ClientRequest<Todos_TodoID>,
            serializer: some GRPCCore.MessageSerializer<Todos_TodoID>,
            deserializer: some GRPCCore.MessageDeserializer<Todos_Todo>,
            options: GRPCCore.CallOptions = .defaults,
            onResponse handleResponse: @Sendable @escaping (GRPCCore.ClientResponse<Todos_Todo>) async throws -> Result = { response in
                try response.message
            }
        ) async throws -> Result where Result: Sendable {
            try await self.client.unary(
                request: request,
                descriptor: Todos_TodoService.Method.CompleteTodo.descriptor,
                serializer: serializer,
                deserializer: deserializer,
                options: options,
                onResponse: handleResponse
            )
        }
    }
}

// Helpers providing default arguments to 'ClientProtocol' methods.
extension Todos_TodoService.ClientProtocol {
    /// Call the "FetchTodos" method.
    ///
    /// > Source IDL Documentation:
    /// >
    /// > 3.
    ///
    /// - Parameters:
    ///   - request: A request containing a single `Todos_Empty` message.
    ///   - options: Options to apply to this RPC.
    ///   - handleResponse: A closure which handles the response, the result of which is
    ///       returned to the caller. Returning from the closure will cancel the RPC if it
    ///       hasn't already finished.
    /// - Returns: The result of `handleResponse`.
    internal func fetchTodos<Result>(
        request: GRPCCore.ClientRequest<Todos_Empty>,
        options: GRPCCore.CallOptions = .defaults,
        onResponse handleResponse: @Sendable @escaping (GRPCCore.ClientResponse<Todos_TodoList>) async throws -> Result = { response in
            try response.message
        }
    ) async throws -> Result where Result: Sendable {
        try await self.fetchTodos(
            request: request,
            serializer: GRPCProtobuf.ProtobufSerializer<Todos_Empty>(),
            deserializer: GRPCProtobuf.ProtobufDeserializer<Todos_TodoList>(),
            options: options,
            onResponse: handleResponse
        )
    }

    /// Call the "CreateTodo" method.
    ///
    /// > Source IDL Documentation:
    /// >
    /// > 4.
    ///
    /// - Parameters:
    ///   - request: A request containing a single `Todos_Todo` message.
    ///   - options: Options to apply to this RPC.
    ///   - handleResponse: A closure which handles the response, the result of which is
    ///       returned to the caller. Returning from the closure will cancel the RPC if it
    ///       hasn't already finished.
    /// - Returns: The result of `handleResponse`.
    internal func createTodo<Result>(
        request: GRPCCore.ClientRequest<Todos_Todo>,
        options: GRPCCore.CallOptions = .defaults,
        onResponse handleResponse: @Sendable @escaping (GRPCCore.ClientResponse<Todos_Todo>) async throws -> Result = { response in
            try response.message
        }
    ) async throws -> Result where Result: Sendable {
        try await self.createTodo(
            request: request,
            serializer: GRPCProtobuf.ProtobufSerializer<Todos_Todo>(),
            deserializer: GRPCProtobuf.ProtobufDeserializer<Todos_Todo>(),
            options: options,
            onResponse: handleResponse
        )
    }

    /// Call the "DeleteTodo" method.
    ///
    /// > Source IDL Documentation:
    /// >
    /// > 5.
    ///
    /// - Parameters:
    ///   - request: A request containing a single `Todos_TodoID` message.
    ///   - options: Options to apply to this RPC.
    ///   - handleResponse: A closure which handles the response, the result of which is
    ///       returned to the caller. Returning from the closure will cancel the RPC if it
    ///       hasn't already finished.
    /// - Returns: The result of `handleResponse`.
    internal func deleteTodo<Result>(
        request: GRPCCore.ClientRequest<Todos_TodoID>,
        options: GRPCCore.CallOptions = .defaults,
        onResponse handleResponse: @Sendable @escaping (GRPCCore.ClientResponse<Todos_Empty>) async throws -> Result = { response in
            try response.message
        }
    ) async throws -> Result where Result: Sendable {
        try await self.deleteTodo(
            request: request,
            serializer: GRPCProtobuf.ProtobufSerializer<Todos_TodoID>(),
            deserializer: GRPCProtobuf.ProtobufDeserializer<Todos_Empty>(),
            options: options,
            onResponse: handleResponse
        )
    }

    /// Call the "CompleteTodo" method.
    ///
    /// > Source IDL Documentation:
    /// >
    /// > 6.
    ///
    /// - Parameters:
    ///   - request: A request containing a single `Todos_TodoID` message.
    ///   - options: Options to apply to this RPC.
    ///   - handleResponse: A closure which handles the response, the result of which is
    ///       returned to the caller. Returning from the closure will cancel the RPC if it
    ///       hasn't already finished.
    /// - Returns: The result of `handleResponse`.
    internal func completeTodo<Result>(
        request: GRPCCore.ClientRequest<Todos_TodoID>,
        options: GRPCCore.CallOptions = .defaults,
        onResponse handleResponse: @Sendable @escaping (GRPCCore.ClientResponse<Todos_Todo>) async throws -> Result = { response in
            try response.message
        }
    ) async throws -> Result where Result: Sendable {
        try await self.completeTodo(
            request: request,
            serializer: GRPCProtobuf.ProtobufSerializer<Todos_TodoID>(),
            deserializer: GRPCProtobuf.ProtobufDeserializer<Todos_Todo>(),
            options: options,
            onResponse: handleResponse
        )
    }
}

// Helpers providing sugared APIs for 'ClientProtocol' methods.
extension Todos_TodoService.ClientProtocol {
    /// Call the "FetchTodos" method.
    ///
    /// > Source IDL Documentation:
    /// >
    /// > 3.
    ///
    /// - Parameters:
    ///   - message: request message to send.
    ///   - metadata: Additional metadata to send, defaults to empty.
    ///   - options: Options to apply to this RPC, defaults to `.defaults`.
    ///   - handleResponse: A closure which handles the response, the result of which is
    ///       returned to the caller. Returning from the closure will cancel the RPC if it
    ///       hasn't already finished.
    /// - Returns: The result of `handleResponse`.
    internal func fetchTodos<Result>(
        _ message: Todos_Empty,
        metadata: GRPCCore.Metadata = [:],
        options: GRPCCore.CallOptions = .defaults,
        onResponse handleResponse: @Sendable @escaping (GRPCCore.ClientResponse<Todos_TodoList>) async throws -> Result = { response in
            try response.message
        }
    ) async throws -> Result where Result: Sendable {
        let request = GRPCCore.ClientRequest<Todos_Empty>(
            message: message,
            metadata: metadata
        )
        return try await self.fetchTodos(
            request: request,
            options: options,
            onResponse: handleResponse
        )
    }

    /// Call the "CreateTodo" method.
    ///
    /// > Source IDL Documentation:
    /// >
    /// > 4.
    ///
    /// - Parameters:
    ///   - message: request message to send.
    ///   - metadata: Additional metadata to send, defaults to empty.
    ///   - options: Options to apply to this RPC, defaults to `.defaults`.
    ///   - handleResponse: A closure which handles the response, the result of which is
    ///       returned to the caller. Returning from the closure will cancel the RPC if it
    ///       hasn't already finished.
    /// - Returns: The result of `handleResponse`.
    internal func createTodo<Result>(
        _ message: Todos_Todo,
        metadata: GRPCCore.Metadata = [:],
        options: GRPCCore.CallOptions = .defaults,
        onResponse handleResponse: @Sendable @escaping (GRPCCore.ClientResponse<Todos_Todo>) async throws -> Result = { response in
            try response.message
        }
    ) async throws -> Result where Result: Sendable {
        let request = GRPCCore.ClientRequest<Todos_Todo>(
            message: message,
            metadata: metadata
        )
        return try await self.createTodo(
            request: request,
            options: options,
            onResponse: handleResponse
        )
    }

    /// Call the "DeleteTodo" method.
    ///
    /// > Source IDL Documentation:
    /// >
    /// > 5.
    ///
    /// - Parameters:
    ///   - message: request message to send.
    ///   - metadata: Additional metadata to send, defaults to empty.
    ///   - options: Options to apply to this RPC, defaults to `.defaults`.
    ///   - handleResponse: A closure which handles the response, the result of which is
    ///       returned to the caller. Returning from the closure will cancel the RPC if it
    ///       hasn't already finished.
    /// - Returns: The result of `handleResponse`.
    internal func deleteTodo<Result>(
        _ message: Todos_TodoID,
        metadata: GRPCCore.Metadata = [:],
        options: GRPCCore.CallOptions = .defaults,
        onResponse handleResponse: @Sendable @escaping (GRPCCore.ClientResponse<Todos_Empty>) async throws -> Result = { response in
            try response.message
        }
    ) async throws -> Result where Result: Sendable {
        let request = GRPCCore.ClientRequest<Todos_TodoID>(
            message: message,
            metadata: metadata
        )
        return try await self.deleteTodo(
            request: request,
            options: options,
            onResponse: handleResponse
        )
    }

    /// Call the "CompleteTodo" method.
    ///
    /// > Source IDL Documentation:
    /// >
    /// > 6.
    ///
    /// - Parameters:
    ///   - message: request message to send.
    ///   - metadata: Additional metadata to send, defaults to empty.
    ///   - options: Options to apply to this RPC, defaults to `.defaults`.
    ///   - handleResponse: A closure which handles the response, the result of which is
    ///       returned to the caller. Returning from the closure will cancel the RPC if it
    ///       hasn't already finished.
    /// - Returns: The result of `handleResponse`.
    internal func completeTodo<Result>(
        _ message: Todos_TodoID,
        metadata: GRPCCore.Metadata = [:],
        options: GRPCCore.CallOptions = .defaults,
        onResponse handleResponse: @Sendable @escaping (GRPCCore.ClientResponse<Todos_Todo>) async throws -> Result = { response in
            try response.message
        }
    ) async throws -> Result where Result: Sendable {
        let request = GRPCCore.ClientRequest<Todos_TodoID>(
            message: message,
            metadata: metadata
        )
        return try await self.completeTodo(
            request: request,
            options: options,
            onResponse: handleResponse
        )
    }
}

// snippet.todo_service_protocol
actor TodoService: Todos_TodoService.ServiceProtocol {

    var todos: [Todos_Todo]
    
    init(
        todos: [Todos_Todo] = []
    ) {
        self.todos = todos
    }

    func createTodo(
        request: ServerRequest<Todos_Todo>,
        context: ServerContext
    ) async throws -> ServerResponse<Todos_Todo> {
        todos.append(request.message)
        return .init(message: request.message)
    }
    
    func fetchTodos(
        request: ServerRequest<Todos_Empty>,
        context: ServerContext
    ) async throws -> ServerResponse<Todos_TodoList> {
        var result = Todos_TodoList()
        result.todos = todos
        return .init(message: result)
    }
    
    func completeTodo(
        request: ServerRequest<Todos_TodoID>,
        context: ServerContext
    ) async throws -> ServerResponse<Todos_Todo> {
        guard
            var todo = todos.first(where: { $0.todoID == request.message.todoID })
        else {
            return .init(
                error: RPCError.init(
                    code: .notFound,
                    message: "Todo not found."
                )
            )
        }
        todo.completed = true
        todos = todos.filter { $0.todoID != request.message.todoID }
        todos.append(todo)
        return .init(message: todo)

    }
    
    func deleteTodo(
        request: ServerRequest<Todos_TodoID>,
        context: ServerContext
    ) async throws -> ServerResponse<Todos_Empty> {
        guard
            let todo = todos.first(where: { $0.todoID == request.message.todoID })
        else {
            return .init(
                error: RPCError.init(
                    code: .notFound,
                    message: "Todo not found."
                )
            )
        }
        todos = todos.filter { $0.todoID != todo.todoID }
        return .init(message: .init())
    }
}
// snippet.end

// snippet.app_entrypoint
import ArgumentParser
import GRPCNIOTransportHTTP2
import GRPCProtobuf

@main
struct Entrypoint: AsyncParsableCommand {
    
    @Option(name: .shortAndLong)
    var hostname: String = "127.0.0.1"
    
    @Option(name: .shortAndLong)
    var port: Int = 1234
    
    func run() async throws {
        // 1.
        let server = GRPCServer(
            transport: .http2NIOPosix(
                address: .ipv4(host: hostname, port: port),
                transportSecurity: .plaintext,
                config: .defaults
            ),
            services: [
                // 2.
                TodoService()
            ]
        )

        // 3.
        try await withThrowingDiscardingTaskGroup { group in
            group.addTask { try await server.serve() }

            // 4.
            if let address = try await server.listeningAddress {
                print("gRPC server listening on \(address)")
            }
        }
    }
}
// snippet.end
